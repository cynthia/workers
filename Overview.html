<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- when publishing, change bits marked ZZZ -->

<html lang=en-US-x-Hixie>
 <head>
  <title>Web Workers</title>
  <link href="http://www.w3.org/StyleSheets/TR/%57%33%43-ED" rel=stylesheet
  type="text/css">
  <!-- ZZZ ED vs WD -->

 <body>
  <div class=head>
   <p><a href="http://www.w3.org/"><img alt=W3C height=48
    src="http://www.w3.org/Icons/w3c_home" width=72></a></p>

   <h1>Web Workers</h1>

   <h2 class="no-num no-toc" id=editors><!-- "W3C Working Draft" --> Editor's
    Draft <!--ZZZ-->16 December 2008</h2>

   <dl><!-- ZZZ: update the month/day
    <dt>This Version:</dt>
    <dd><a href="http://www.w3.org/TR/2008/WD-workers-20080101/">http://www.w3.org/TR/2008/WD-workers-20080101/</a></dd>
    <dt>Latest Published Version:</dt>
    <dd><a href="http://www.w3.org/TR/workers/">http://www.w3.org/TR/workers/</a></dd>
 :ZZZ -->

    <dt>Latest Editor's Draft:

    <dd><a
     href="http://dev.w3.org/html5/workers/">http://dev.w3.org/html5/workers/</a></dd>
    <!-- ZZZ: add the new version after it has shipped
    <dt>Previous Versions:</dt>
    <dd><a href="http://www.w3.org/TR/2008/WD-workers-20080101/">http://www.w3.org/TR/2008/WD-workers-20080101/</a>
 :ZZZ -->

    <dt>Editors:

    <dd><a href="mailto:ian@hixie.ch">Ian Hickson</a>, Google, Inc.
   </dl>

   <p class=copyright><a
    href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>
    &#169; 2008 <a href="http://www.w3.org/"><abbr title="World Wide Web
    Consortium">W3C</abbr></a><sup>&#174;</sup> (<a
    href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of
    Technology">MIT</abbr></a>, <a href="http://www.ercim.org/"><abbr
    title="European Research Consortium for Informatics and
    Mathematics">ERCIM</abbr></a>, <a
    href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C <a
    href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
    <a
    href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
    and <a
    href="http://www.w3.org/Consortium/Legal/copyright-documents">document
    use</a> rules apply.</p>
   <!-- UNDER NO CIRCUMSTANCES IS THE FOLLOWING PARAGRAPH TO BE REMOVED OR EDITED WITHOUT TALKING TO IAN FIRST -->
   
   <p class="alt copyright">The <a
    href="http://www.whatwg.org/specs/web-workers/current-work/">WHATWG
    version</a> of this specification is available under a more permissive
    license.</p>
   <!-- UNDER NO CIRCUMSTANCES IS THE PRECEDING PARAGRAPH TO BE REMOVED OR EDITED WITHOUT TALKING TO IAN FIRST -->
   </div>

  <hr>

  <h2 class="no-num no-toc" id=abstract>Abstract</h2>

  <p>This specification defines an API that allows Web application authors to
   spawn background workers running scripts in parallel to their main page.
   This allows for thread-like operation with message-passing as the
   coordination mechanism.

  <h2 class="no-num no-toc" id=status>Status of this document</h2>
  <!-- intro boilerplate (required) -->

  <p><em>This section describes the status of this document at the time of
   its publication. Other documents may supersede this document. A list of
   current W3C publications and the most recently formally published revision
   of this technical report can be found in the <a
   href="http://www.w3.org/TR/">W3C technical reports index</a> at
   http://www.w3.org/TR/.</em></p>
  <!-- where to send feedback (required) -->

  <p>If you wish to make comments regarding this document, please send them
   to <a
   href="mailto:public-webapps-comments@w3.org">public-webapps-comments@w3.org</a>
   (<a
   href="mailto:public-webapps-comments-request@w3.org?subject=subscribe">subscribe</a>,
   <a
   href="http://lists.w3.org/Archives/Public/public-webapps-comments/">archives</a>)
   <!-- UNDER NO CIRCUMSTANCES IS THE FOLLOWING SENTENCE TO BE REMOVED OR EDITED WITHOUT TALKING TO IAN FIRST -->
   or <a href="mailto:whatwg@whatwg.org">whatwg@whatwg.org</a> (<a
   href="http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org">subscribe</a>,
   <a
   href="http://lists.whatwg.org/pipermail/whatwg-whatwg.org/">archives</a>).
   <!-- UNDER NO CIRCUMSTANCES IS THE PRECEDING SENTENCE TO BE REMOVED OR EDITED WITHOUT TALKING TO IAN FIRST -->
   All feedback is welcome.</p>
  <!-- stability (required) -->

  <p>Implementors should be aware that this specification is not stable.
   <strong>Implementors who are not taking part in the discussions are likely
   to find the specification changing out from under them in incompatible
   ways.</strong> Vendors interested in implementing this specification
   before it eventually reaches the Candidate Recommendation stage should
   join the aforementioned mailing lists and take part in the discussions.</p>
  <!-- UNDER NO CIRCUMSTANCES IS THE FOLLOWING PARAGRAPH TO BE REMOVED OR EDITED WITHOUT TALKING TO IAN FIRST -->
  <!-- version history or list of changes (required) -->

  <p>The latest stable version of the editor's draft of this specification is
   always available on <a
   href="http://dev.w3.org/html5/workers/Overview.html">the W3C CVS
   server</a> and in the <a href="http://svn.whatwg.org/webworkers/">WHATWG
   Subversion repository</a>. The latest editor's working copy (which may
   contain unfinished text in the process of being prepared) is available <a
   href="http://www.whatwg.org/specs/web-workers/current-work/">on the WHATWG
   site</a>. Detailed change history can be obtained from the following
   locations:</p>
  <!-- UNDER NO CIRCUMSTANCES IS THE PRECEDING PARAGRAPH TO BE REMOVED OR EDITED WITHOUT TALKING TO IAN FIRST -->
  <!-- UNDER NO CIRCUMSTANCES IS THE FOLLOWING LIST TO BE REMOVED OR EDITED WITHOUT TALKING TO IAN FIRST -->

  <ul>
   <li>Twitter messages (non-editorial changes only): <a
    href="http://twitter.com/WHATWG">http://twitter.com/WHATWG</a>

   <li>Interactive Web interface: <a
    href="http://html5.org/tools/web-workers-tracker">http://html5.org/tools/web-workers-tracker</a>

   <li>Commit-Watchers mailing list: <a
    href="http://lists.whatwg.org/listinfo.cgi/commit-watchers-whatwg.org">http://lists.whatwg.org/listinfo.cgi/commit-watchers-whatwg.org</a>

   <li>Subversion interface: <a
    href="http://svn.whatwg.org/webworkers/">http://svn.whatwg.org/webworkers/</a>

   <li>CVS log: <a
    href="http://dev.w3.org/cvsweb/html5/workers/Overview.html">http://dev.w3.org/cvsweb/html5/workers/Overview.html</a>
  </ul>
  <!-- UNDER NO CIRCUMSTANCES IS THE PRECEDING LIST TO BE REMOVED OR EDITED WITHOUT TALKING TO IAN FIRST -->
  <!-- status of document, group responsible (required) -->

  <p>The W3C <a href="http://www.w3.org/2008/webapps/">Web Apps Working
   Group</a> is the W3C working group responsible for this specification's
   progress along the W3C Recommendation track. <!--ZZZ:--> This
   specification is the 16 December 2008 <!--ZZZ "Working Draft"-->Editor's
   Draft. <!--:ZZZ--></p>
  <!-- UNDER NO CIRCUMSTANCES IS THE PRECEDING PARAGRAPH TO BE REMOVED OR EDITED WITHOUT TALKING TO IAN FIRST -->
  <!-- relationship to other work (required) -->

  <p>This specification is also being produced by the <a
   href="http://www.whatwg.org/">WHATWG</a>. The two specifications are
   identical from the table of contents onwards.</p>
  <!-- UNDER NO CIRCUMSTANCES IS THE FOLLOWING PARAGRAPH TO BE REMOVED OR EDITED WITHOUT TALKING TO IAN FIRST -->
  <!-- UNDER NO CIRCUMSTANCES IS THE PRECEDING PARAGRAPH TO BE REMOVED OR EDITED WITHOUT TALKING TO IAN FIRST -->
  <!-- context and rationale (required) -->

  <p>This specification is intended to specify a part of the Web platform
   closely related to HTML5. It is defined in a separate document primarily
   to ease the cognitive load on reviewers.</p>
  <!-- UNDER NO CIRCUMSTANCES IS THE FOLLOWING PARAGRAPH TO BE REMOVED OR EDITED WITHOUT TALKING TO IAN FIRST -->
  <!-- required patent boilerplate -->

  <p>This document was produced by a group operating under the <a
   href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February
   2004 W3C Patent Policy</a>. W3C maintains a <a
   href="http://www.w3.org/2004/01/pp-impl/42538/status"
   rel=disclosure>public list of any patent disclosures</a> made in
   connection with the deliverables of the group; that page also includes
   instructions for disclosing a patent. An individual who has actual
   knowledge of a patent which the individual believes contains <a
   href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential
   Claim(s)</a> must disclose the information in accordance with <a
   href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section
   6 of the W3C Patent Policy</a>.

  <h2 class="no-num no-toc" id=contents>Table of contents</h2>
  <!--begin-toc-->

  <ul class=toc>
   <li><a href="#introduction"><span class=secno>1. </span>Introduction</a>
    <ul class=toc>
     <li><a href="#scope"><span class=secno>1.1 </span>Scope</a>

     <li><a href="#tutorial"><span class=secno>1.2 </span>Tutorial</a>
      <ul class=toc>
       <li><a href="#a-background"><span class=secno>1.2.1 </span>A
        background number-crunching worker</a>

       <li><a href="#a-worker"><span class=secno>1.2.2 </span>A worker for
        updating a client-side database</a>

       <li><a href="#worker"><span class=secno>1.2.3 </span>Worker used for
        background I/O</a>

       <li><a href="#shared"><span class=secno>1.2.4 </span>Shared
        workers</a>

       <li><a href="#delegation"><span class=secno>1.2.5
        </span>Delegation</a>

       <li><a href="#providing"><span class=secno>1.2.6 </span>Providing
        libraries</a>
      </ul>

     <li><a href="#conformance"><span class=secno>1.3 </span>Conformance
      requirements</a>
      <ul class=toc>
       <li><a href="#dependencies"><span class=secno>1.3.1
        </span>Dependencies</a>
      </ul>

     <li><a href="#terminology"><span class=secno>1.4 </span>Terminology</a>
    </ul>

   <li><a href="#infrastructure"><span class=secno>2.
    </span>Infrastructure</a>
    <ul class=toc>
     <li><a href="#the-global"><span class=secno>2.1 </span>The global
      scope</a>
      <ul class=toc>
       <li><a href="#the-workerglobalscope"><span class=secno>2.1.1
        </span>The <code>WorkerGlobalScope</code> abstract interface</a>

       <li><a href="#dedicated"><span class=secno>2.1.2 </span>Dedicated
        workers and the <code>DedicatedWorkerGlobalScope</code> interface</a>
        

       <li><a href="#shared0"><span class=secno>2.1.3 </span>Shared workers
        and the <code>SharedWorkerGlobalScope</code> inteface</a>
      </ul>

     <li><a href="#base-urls"><span class=secno>2.2 </span>Base URLs and
      origins of workers</a>

     <li><a href="#the-event"><span class=secno>2.3 </span>The event loop</a>
      

     <li><a href="#the-workers"><span class=secno>2.4 </span>The worker's
      ports</a>

     <li><a href="#processing"><span class=secno>2.5 </span>Processing
      model</a>

     <li><a href="#creating"><span class=secno>2.6 </span>Creating
      workers</a>
      <ul class=toc>
       <li><a href="#the-abstractworker"><span class=secno>2.6.1 </span>The
        <code>AbstractWorker</code> abstract interface</a>

       <li><a href="#dedicated0"><span class=secno>2.6.2 </span>Dedicated
        workers and the <code>Worker</code> interface</a>

       <li><a href="#shared1"><span class=secno>2.6.3 </span>Shared workers
        and the <code>SharedWorker</code> interface</a>
      </ul>
    </ul>

   <li><a href="#apis-available"><span class=secno>3. </span>APIs available
    to workers</a>
    <ul class=toc>
     <li><a href="#importing"><span class=secno>3.1 </span>Importing scripts
      and libraries</a>

     <li><a href="#the-navigator"><span class=secno>3.2 </span>The
      <code>Navigator</code> object</a>

     <li><a href="#apis-defined"><span class=secno>3.3 </span>APIs defined in
      other specifications</a>

     <li><a href="#interface"><span class=secno>3.4 </span>Interface objects
      and constructors</a>

     <li><a href="#worker0"><span class=secno>3.5 </span>Worker locations</a>
      
    </ul>

   <li class=no-num><a href="#references">References</a>

   <li class=no-num><a href="#acknowledgements">Acknowledgements</a>
  </ul>
  <!--end-toc-->

  <hr>

  <h2 id=introduction><span class=secno>1. </span>Introduction</h2>

  <h3 id=scope><span class=secno>1.1 </span>Scope</h3>

  <p><em>This section is non-normative.</em>

  <p>This specification defines an API for running scripts in the background
   independently of any user interface scripts.

  <p>This allows for long-running scripts that are not interrupted by scripts
   that respond to clicks or other user interactions, and allows long tasks
   to be executed without yielding to keep the page responsive.

  <p>Workers (as these background scripts are called herein) are relatively
   heavy-weight, and are not intended to be used in large numbers. For
   example, it would be inappropriate to launch one worker for each pixel of
   a four megapixel image. The examples below show some appropriate uses of
   workers.

  <p>Generally, workers are expected to be long-lived, have a high start-up
   performance cost, and a high per-instance memory cost.

  <h3 id=tutorial><span class=secno>1.2 </span>Tutorial</h3>

  <p><em>This section is non-normative.</em>

  <p>There are a variety of uses that workers can be put to. The following
   subsections show various examples of this use.

  <h4 id=a-background><span class=secno>1.2.1 </span>A background
   number-crunching worker</h4>

  <p><em>This section is non-normative.</em>

  <p>The simplest use of workers is for performing a computationally
   expensive task without interrupting the user interface.

  <p>In this example, the main document spawns a worker to (na&iuml;vely)
   compute prime numbers, and progressively displays the most recently found
   prime number.

  <p>The main page is as follows:

  <pre>&lt;!DOCTYPE HTML>
&lt;html>
 &lt;head>
  &lt;title>Worker example: One-core computation&lt;/title>
 &lt;/head>
 &lt;body>
  &lt;p>The highest prime number discovered so far is: &lt;output id="result">&lt;/output>&lt;/p>
  &lt;script>
   var worker = new Worker('worker.js');
   worker.onmessage = function (event) {
     document.getElementById('result').textContent = event.data;
   };
  &lt;/script>
 &lt;/body>
&lt;/html></pre>

  <p>The <code title=dom-Worker><a href="#worker2">Worker()</a></code>
   constructor call creates a worker and returns a <code><a
   href="#worker1">Worker</a></code> object representing that worker, which
   is used to communicate with the worker. That object's <code
   title=handler-Worker-onmessage><a href="#onmessage0">onmessage</a></code>
   event handler attribute allows the code to receive messages from the
   worker.

  <p>The worker itself is as follows:

  <pre>var n = 1;
search: while (true) {
  n += 1;
  for (var i = 2; i &lt;= Math.sqrt(n); i += 1)
    if (n % i == 0)
     continue search;
  // found a prime!
  postMessage(n);
}</pre>

  <p>The bulk of this code is simply an unoptimised search for a prime
   number. To send a message back to the page, the <code
   title=dom-DedicatedWorkerGlobalScope-postMessage><a
   href="#postmessage">postMessage()</a></code> method is used to post a
   message when a prime is found.

  <p><a href="http://www.whatwg.org/demos/workers/primes/page.html">View this
   example online</a>.

  <h4 id=a-worker><span class=secno>1.2.2 </span>A worker for updating a
   client-side database</h4>

  <p><em>This section is non-normative.</em>

  <p>In this example, the main document spawns a worker whose only task is to
   listen for notifications from the server, and, when appropriate, either
   add or remove data from the client-side database.

  <p>Since no communication occurs between the worker and the main page, the
   main page can start the worker by just doing:

  <pre>&lt;script>
 new Worker('worker.js');
&lt;/script></pre>

  <p>The worker itself is as follows:

  <pre>var server = new WebSocket('ws://whatwg.org/database');
var database = openDatabase('demobase', '1.0', 'Demo Database', 10240);
server.onmessage = function (event) {
  // data is in the format "command key value"
  var data = event.data.split(' ');
  switch (data[0]) {
    case '+':
     database.transaction(function(tx) {
       tx.executeSql('INSERT INTO pairs (key, value) VALUES (?, ?)', data[1], data[2]);
     });
    case '-':
     database.transaction(function(tx) {
       tx.executeSql('DELETE FROM pairs WHERE key=? AND value=?', data[1], data[2]);
     });
  }
};</pre>

  <p>This connects to the server using the <code>WebSocket</code> mechanism
   and opens the local database (which, we presume, has been created
   earlier). The worker then just listens for messages from the server and
   acts on them as appropriate, forever (or until the main page is closed).

  <p><a
   href="http://www.whatwg.org/demos/workers/database-updater/page.html">View
   this example online</a>. (This example will not actually function, since
   the server does not actually exist and the database is not created by this
   sample code.)

  <h4 id=worker><span class=secno>1.2.3 </span>Worker used for background I/O</h4>

  <p><em>This section is non-normative.</em>

  <p>In this example, the main document uses two workers, one for fetching
   stock updates for at regular intervals, and one for fetching performing
   search queries that the user requests.

  <p>The main page is as follows:

  <pre>&lt;!DOCTYPE HTML>
&lt;html>
 &lt;head>
  &lt;title>Worker example: Stock ticker&lt;/title>
  &lt;script>
   // TICKER
   var symbol = 'GOOG'; // default symbol to watch
   var ticker = new Worker('ticker.js');

   // SEARCHER
   var searcher = new Worker('searcher.js');
   function search(query) {
     searcher.postMessage(query);
   }

   // SYMBOL SELECTION UI
   function select(newSymbol) {
     symbol = newSymbol;
     ticker.postMessage(symbol);
   }
  &lt;/script>
 &lt;/head>
 &lt;body>
  &lt;p>&lt;output id="symbol">&lt;/output> &lt;output id="value">&lt;/output>&lt;/p>
  &lt;script>
   ticker.onmessage = function (event) {
     var data = event.data.split(' ');
     document.getElementById('symbol').textContent = data[0];
     document.getElementById('value').textContent = data[1];
   };
   ticker.postMessage(symbol);
  &lt;/script>
  &lt;p>&lt;label>Search: &lt;input type="text" oninput="search(this.value)">&lt;/label>&lt;/p>
  &lt;ul id="results">&lt;/ul>
  &lt;script>
   searcher.onmessage = function (event) {
     var data = event.data.split(' ');
     var results = document.getElementById('results');
     while (results.hasChildNodes()) // clear previous results
       results.removeChild(results.firstChild);
     for (var i = 0; i &lt; data.length; i += 1) {
       // add a list item with a button for each result
       var li = document.createElement('li');
       var button = document.createElement('button');
       button.value = data[i];
       button.type = 'button';
       button.onclick = function () { select(this.value); };
       button.textContent = data[i];
       li.appendChild(button);
       results.appendChild(li);
     }
   };
  &lt;/script>
  &lt;p>(The data in this example is not real. Try searching for "Google" or "Apple".)&lt;/p>
 &lt;/body>
&lt;/html></pre>

  <p>The two workers use a common library for performing the actual network
   calls. This library is as follows:

  <pre>function get(url) {
  try {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, false);
    xhr.send();
    return xhr.responseText;
  } catch (e) {
    return ''; // turn all errors into empty results
  }
}</pre>

  <p>The stock updater worker is as follows:

  <pre>importScripts('io.js');
var timer;
var symbol;
function update() {
  postMessage(symbol + ' ' + get('stock.cgi?' + symbol));
  timer = setTimeout(update, 10000);
}
onmessage = function (event) {
  if (timer)
    clearTimeout(timer);
  symbol = event.data;
  update();
};</pre>

  <p>The search query worker is as follows:

  <pre>importScripts('io.js');
onmessage = function (event) {
  postMessage(get('search.cgi?' + event.data));
};</pre>

  <p><a href="http://www.whatwg.org/demos/workers/stocks/page.html">View this
   example online</a>.

  <h4 id=shared><span class=secno>1.2.4 </span>Shared workers</h4>

  <p><em>This section is non-normative.</em>

  <p>In this example, multiple windows (viewers) can be opened that are all
   viewing the same map. All the windows share the same map information, with
   a single worker coordinating all the viewers. Each viewer can move around
   independently, but if they set any data on the map, all the viewers are
   updated.

  <p>The main page isn't interesting, it merely provides a way to open the
   viewers:

  <pre>&lt;!DOCTYPE HTML>
&lt;html>
 &lt;head>
  &lt;title>Workers example: Multiviewer&lt;/title>
  &lt;script>
   function openViewer() {
     window.open('viewer.html');
   }
  &lt;/script>
 &lt;/head>
 &lt;body>
  &lt;p>&lt;button type=button onclick="openViewer()">Open a new
  viewer&lt;/button>&lt;/p>
  &lt;p>Each viewer opens in a new window. You can have as many viewers
  as you like, they all view the same data.&lt;/p>
 &lt;/body>
&lt;/html></pre>

  <p>The viewer is more involved:

  <pre>&lt;!DOCTYPE HTML>
&lt;html>
 &lt;head>
  &lt;title>Workers example: Multiviewer viewer&lt;/title>
  &lt;script>
   var worker = new SharedWorker('worker.js', 'core');

   // CONFIGURATION
   function configure(event) {
     if (event.data.substr(0, 4) != 'cfg ') return;
     var name = event.data.substr(4).split(' ', 1);
     // update display to mention our name is name
     document.getElementsByTagName('h1')[0].textContent += ' ' + name;
     // no longer need this listener
     worker.port.removeEventListener('message', configure, false);
   }
   worker.port.addEventListener('message', configure, false);

   // MAP
   function paintMap(event) {
     if (event.data.substr(0, 4) != 'map ') return;
     var data = event.data.substr(4).split(',');
     // display tiles data[0] .. data[8]
     var canvas = document.getElementById('map');
     var context = canvas.getContext('2d');
     for (var y = 0; y &lt; 3; y += 1) {
       for (var x = 0; x &lt; 3; x += 1) {
         var tile = data[y * 3 + x];
         if (tile == '0')
           context.fillStyle = 'green';
         else 
           context.fillStyle = 'maroon';
         fillRect(x * 50, y * 50, 50, 50);
       }
     }
   }
   worker.port.addEventListener('message', paintMap, false);

   // PUBLIC CHAT
   function updatePublicChat(event) {
     if (event.data.substr(0, 4) != 'txt ') return;
     var name = event.data.substr(4).split(' ', 1);
     var message = event.data.substr(4 + length(name) + 1);
     // display "&lt;name> message" in public chat
     var dialog = document.getElementById('public');
     var dt = document.createElement('dt');
     dt.textContent = name;
     dialog.appendChild(dt);
     var dd = document.createElement('dd');
     dd.textContent = message;
     dialog.appendChild(dd);
   }
   worker.port.addEventListener('message', updatePublicChat, false);

   // PRIVATE CHAT
   function startPrivateChat(event) {
     if (event.data.substr(0, 4) != 'msg ') return;
     var name = event.data.substr(4).split(' ', 1);
     var port = event.port;
     // display a private chat UI
     var ul = document.getElementById('private');
     var li = document.createElement('li');
     var h3 = document.createElement('h3');
     h3.textContent = 'Private chat with ' + name;
     li.appendChild(h3);
     var dialog = document.createElement('dialog');
     var addMessage = function(name, message) {
       var dt = document.createElement('dt');
       dt.textContent = name;
       dialog.appendChild(dt);
       var dd = document.createElement('dd');
       dd.textContent = message;
       dialog.appendChild(dd);
     };
     port.onmessage = function (event) {
       addMessage(name, event.data);
     };
     li.appendChild(dialog);
     var form = document.createElement('form');
     var p = document.createElement('p');
     var input = document.createElement('input');
     input.size = 50;
     p.appendChild(input);
     p.appendChild(document.createTextNode(' '));
     var button = document.createElement('button');
     button.textContent = 'Post';
     p.appendChild(button);
     form.onsubmit = function () {
       port.postMessage(input.value);
       addMessage('me', input.value);
       input.value = '';
       return false;
     };
     form.appendChild(p);
     li.appendChild(form);
   }
   worker.port.addEventListener('message', startPrivateChat, false);
  &lt;/script>
 &lt;/head>
 &lt;body>
  &lt;h1>Viewer&lt;/h1>
  &lt;h2>Map&lt;/h2>
  &lt;p>&lt;canvas id="map" height=150 width=150>&lt;/canvas>&lt;/p>
  &lt;p>
   &lt;button type=button onclick="worker.port.postMessage('mov left')">Left&lt;/button>
   &lt;button type=button onclick="worker.port.postMessage('mov up')">Up&lt;/button>
   &lt;button type=button onclick="worker.port.postMessage('mov down')">Down&lt;/button>
   &lt;button type=button onclick="worker.port.postMessage('mov right')">Right&lt;/button>
   &lt;button type=button onclick="worker.port.postMessage('set 0')">Set 0&lt;/button>
   &lt;button type=button onclick="worker.port.postMessage('set 1')">Set 1&lt;/button>
  &lt;/p>
  &lt;h2>Public Chat&lt;/h2>
  &lt;dialog id="public">&lt;/dialog>
  &lt;form onsubmit="worker.port.postMessage('txt ' + message.value); message.value = ''; return false;">
   &lt;p>
    &lt;input type="text" name="message" size="50">
    &lt;button>Post&lt;/button>
   &lt;/p>
  &lt;/form>
  &lt;h2>Private Chat&lt;/h2>
  &lt;ul id="private">&lt;/ul>
 &lt;/body>
&lt;/html>
</pre>

  <p>There are several key things worth noting about the way the viewer is
   written.

  <p><strong>Multiple listeners</strong>. Instead of a single message
   processing function, the code here attaches multiple event listeners, each
   one performing a quick check to see if it is relevant for the message. In
   this example it doesn't make much difference, but if multiple authors
   wanted to collaborate using a single port to communicate with a worker, it
   would allow for independent code instead of changes having to all be made
   to a single event handling function.

  <p>Registering event listeners in this way also allows you to unregister
   specific listeners when you are done with them, as is done with the <code
   title="">configure()</code> method in this example.

  <p>Finally, the worker:

  <pre>
var nextName = 0;
function getNextName() {
  // this could use more friendly names
  // but for now just return a number
  return nextName++;
}

var map = [
 [0, 0, 0, 0, 0, 0, 0],
 [1, 1, 0, 1, 0, 1, 1],
 [0, 1, 0, 1, 0, 0, 0],
 [0, 1, 0, 1, 0, 1, 1],
 [0, 0, 0, 1, 0, 0, 0],
 [1, 0, 0, 1, 1, 1, 1],
 [1, 1, 0, 1, 1, 0, 1],
];

function wrapX(x) {
  if (x &lt; 0) return wrapX(x + map[0].length);
  if (x >= map[0].length) return wrapX(x - map[0].length);
  return x;
}

function wrapY(y) {
  if (y &lt; 0) return wrapY(y + map.length);
  if (y >= map[0].length) return wrapY(y - map.length);
  return y;
}

function sendMapData(callback) {
  var data = '';
  for (var y = viewer.y-1; y &lt;= viewer.y+1; y += 1) {
    for (var x = viewer.x-1; x &lt;= viewer.x+1; x += 1) {
      if (data != '')
        data += ',';
      data += map[y][x];
    }
  }
  callback('map ' + data);
}

var viewers = {};
onconnect = function (event) {
  event.port._name = getNextName();
  event.port._data = { port: event.port, x: 0, y: 0, };
  viewers[event.port._name] = event.port._data;
  event.port.postMessage('cfg ' + name);
  event.port.onmessage = getMessage;
  sendMapData(event.port.postMessage);
};

function getMessage(event) {
  switch (event.data.substr(0, 4)) {
    case 'mov ':
      var direction = event.data.substr(4);
      var dx = 0;
      var dy = 0;
      switch (direction) {
        case 'up': dy = -1; break;
        case 'down': dy = 1; break;
        case 'left': dx = -1; break;
        case 'right': dx = 1; break;
      }
      event.target._data.x = wrapX(event.target._data.x + dx);
      event.target._data.y = wrapY(event.target._data.y + dy);
      sendMapData(event.target.postMessage);
      break;
    case 'set ':
      var value = event.data.substr(4);
      map[event.target._data.y][event.target._data.x] = value;
      for (var viewer in viewers)
        sendMapData(viewers[viewer].port.postMessage);
      break;
    case 'txt ':
      var name = event.target._name;
      var message = event.data.substr(4);
      for (var viewer in viewers)
        viewers[viewer].port.postMessage('txt ' + name + ' ' + message);
      break;
    case 'msg ':
      var party1 = event._data;
      var party2 = viewers[event.data.substr(4).split(' ', 1)];
      if (party2) {
        var channel = new MessageChannel();
        party1.port.postMessage('msg ' + party2.name, channel.port1);
        party2.port.postMessage('msg ' + party1.name, channel.port2);
      }
      break;
  }
}</pre>

  <p><strong>Connecting to multiple pages</strong>. The script uses the <code
   title=handler-SharedWorkerGlobalScope-onconnect><a
   href="#onconnect">onconnect</a></code> event listener to listen for
   multiple connections.

  <p><strong>Direct channels</strong>. When the worker receives a "msg"
   message from one viewer naming another viewer, it sets up a direct
   connection between the two, so that the two viewers can communicate
   directly without the worker having to proxy all the messages.

  <p><a href="http://www.whatwg.org/demos/workers/multiviewer/page.html">View
   this example online</a>.

  <h4 id=delegation><span class=secno>1.2.5 </span>Delegation</h4>

  <p><em>This section is non-normative.</em>

  <p>With multicore CPUs becoming prevalent, one way to obtain better
   performance is to split computationally expensive tasks amongst multiple
   workers. In this example, a computationally expensive task that is to be
   performed for every number from 1 to 10,000,000 is farmed out to ten
   subworkers.

  <p>The main page is as follows, it just reports the result:

  <pre>&lt;!DOCTYPE HTML>
&lt;html>
 &lt;head>
  &lt;title>Worker example: One-core computation&lt;/title>
 &lt;/head>
 &lt;body>
  &lt;p>The highest prime number discovered so far is: &lt;output id="result">&lt;/output>&lt;/p>
  &lt;script>
   var worker = new Worker('worker.js');
   worker.onmessage = function (event) {
     document.getElementById('result').textContent = event.data;
   };
  &lt;/script>
 &lt;/body>
&lt;/html></pre>

  <p>The worker itself is as follows:

  <pre>// settings
var num_workers = 10;
var items_per_worker = 1000000;

// start the workers
var result = 0;
var pending_workers = num_workers;
for (var i = 0; i &lt; num_workers; i += 1) {
  var worker = new Worker('core.js');
  worker.postMessage(i * items_per_worker);
  worker.postMessage((i+1) * items_per_worker);
  worker.onmessage = storeResult;
}

// handle the results
function storeResult(event) {
  result += 1*event.data;
  pending_workers -= 1;
  if (pending_workers &lt;= 0)
    postMessage(result); // finished!
}</pre>

  <p>It consists of a loop to start the subworkers, and then a handler that
   waits for all the subworkers to respond.

  <p>The subworkers are implemented as follows:

  <pre>var start;
onmessage = getStart;
function getStart(event) {
  start = 1*event.data;
  onmessage = getEnd;
}

var end;
function getEnd(event) {
  end = 1*event.data;
  onmessage = null;
  work();
}

function work() {
  var result = 0;
  for (var i = start; i &lt; end; i += 1) {
    // perform some complex calculation here
    result += 1;
  }
  postMessage(result);
  close();
}</pre>

  <p>They receive two numbers in two events, perform the computation for the
   range of numbers thus specified, and then report the result back to the
   parent.

  <p><a href="http://www.whatwg.org/demos/workers/multicore/page.html">View
   this example online</a>.

  <h4 id=providing><span class=secno>1.2.6 </span>Providing libraries</h4>

  <p><em>This section is non-normative.</em>

  <p>Suppose that a cryptography library is made available that provides
   three tasks:

  <dl>
   <dt>Generate a public/private key pair

   <dd>Takes a port, on which it will send two messages, first the public key
    and then the private key.

   <dt>Given a plaintext and a public key, return the corresponding
    cyphertext

   <dd>Takes a port, to which any number of messages can be sent, the first
    giving the public key, and the remainder giving the plaintext, each of
    which is encrypted and then sent on that same channel as the cyphertext.
    The user can close the port when it is done encrypting content.

   <dt>Given a cyphertext and a private key, return the corresponding
    plaintext

   <dd>Takes a port, to which any number of messages can be sent, the first
    giving the private key, and the remainder giving the cyphertext, each of
    which is decrypted and then sent on that same channel as the plaintext.
    The user can close the port when it is done decrypting content.
  </dl>

  <p>The library itself is as follows:

  <pre>function handleMessage(e) {
  if (e.data == "genkeys")
    genkeys(e.port);
  else if (e.data == "encrypt")
    encrypt(e.port);
  else if (e.data == "decrypt")
    decrypt(e.port);
}

function genkeys(p) {
  var keys = _generateKeyPair();
  p.postMessage(keys[0]);
  p.postMessage(keys[1]);
}

function encrypt(p) {
  var key, state = 0;
  p.onmessage = function (e) {
    if (state == 0) {
      key = e.data;
      state = 1;
    } else {
      p.postMessage(_encrypt(key, e.data));
    }
  };
}

function decrypt(p) {
  var key, state = 0;
  p.onmessage = function (e) {
    if (state == 0) {
      key = e.data;
      state = 1;
    } else {
      p.postMessage(_decrypt(key, e.data));
    }
  };
}

// support being used as a shared worker as well as a dedicated worker
if (this.onmessage) // dedicated worker
  onmessage = handleMessage;
else // shared worker
  onconnect = function (e) { e.port.onmessage = handleMessage; }


// the "crypto" functions:

function _generateKeyPair() {
  return [Math.random(), Math.random()];
}

function _encrypt(k, s) {
  return 'encrypted-' + k + ' ' + s;
}

function _decrypt(k, s) {
  return s.substr(s.indexOf(' ')+1);
}</pre>

  <p>Note that the crypto functions here are just stubs and don't do real
   cryptography.

  <p>This library could be used as follows:

  <pre>&lt;!DOCTYPE HTML>
&lt;html>
 &lt;head>
  &lt;title>Worker example: Crypto library&lt;/title>
  &lt;script>
   var crytoLib = new Worker('libcrypto-v1.js'); // or could use 'libcrypto-v2.js'
   function getKeys() {
     var state = 0;
     cryptoLib.startConversation("genkeys").onmessage = function (e) {
       if (state == 0)
         document.getElementById('public').value = e.data;
       else if (state == 1)
         document.getElementById('private').value = e.data;
       state += 1;
     };
   }
   function enc() {
     var port = cryptoLib.startConversation("encrypt");
     port.postMessage(document.getElementById('public').value);
     port.postMessage(document.getElementById('input').value);
     port.onmessage = function (e) {
       document.getElementById('input').value = e.data;
       port.close();
     };
   }
   function dec() {
     var port = cryptoLib.startConversation("decrypt");
     port.postMessage(document.getElementById('private').value);
     port.postMessage(document.getElementById('input').value);
     port.onmessage = function (e) {
       document.getElementById('input').value = e.data;
       port.close();
     };
   }
  &lt;/script>
  &lt;style>
   textarea { display: block; }
  &lt;/style>
 &lt;/head>
 &lt;body onload="getKeys()">
  &lt;fieldset>
   &lt;legend>Keys&lt;/legend>
   &lt;p>&lt;label>Public Key: &lt;textarea id="public">&lt;/textarea>&lt;/label>&lt;/p>
   &lt;p>&lt;label>Private Key: &lt;textarea id="private">&lt;/textarea>&lt;/label>&lt;/p>
  &lt;/fieldset>
  &lt;p>&lt;label>Input: &lt;textarea id="input">&lt;/textarea>&lt;/label>&lt;/p>
  &lt;p>&lt;button onclick="enc()">Encrypt&lt;/button> &lt;button onclick="dec()">Decrypt&lt;/button>&lt;/p>
 &lt;/body>
&lt;/html></pre>

  <p>A later version of the API, though, might want to offload all the crypto
   work onto subworkers. This could be done as follows:

  <pre>function handleMessage(e) {
  if (e.data == "genkeys")
    genkeys(e.port);
  else if (e.data == "encrypt")
    encrypt(e.port);
  else if (e.data == "decrypt")
    decrypt(e.port);
}

function genkeys(p) {
  var generator = new Worker('libcrypto-v2-generator.js');
  generator.postMessage('', p);
}

function encrypt(p) {
  p.onmessage = function (e) {
    var key = e.data;
    var encryptor = new Worker('libcrypto-v2-encryptor.js');
    encryptor.postMessage(key, p);
  };
}

function encrypt(p) {
  p.onmessage = function (e) {
    var key = e.data;
    var decryptor = new Worker('libcrypto-v2-decryptor.js');
    decryptor.postMessage(key, p);
  };
}

// support being used as a shared worker as well as a dedicated worker
if (this.onmessage) // dedicated worker
  onmessage = handleMessage;
else // shared worker
  onconnect = function (e) { e.port.onmessage = handleMessage; }
</pre>

  <p>The little subworkers would then be as follows.

  <p>For generating key pairs:

  <pre>onmessage = function (e) {
  var k = _generateKeyPair();
  e.port.postMessage(k[0]);
  e.port.postMessage(k[1]);
  close();
}

function _generateKeyPair() {
  return [Math.random(), Math.random()];
}</pre>

  <p>For encrypting:

  <pre>onmessage = function (e) {
  var key = e.data;
  e.port.onmessage = function (e) {
    var s = e.data;
    postMessage(_encrypt(key, s));
  }
  e.port.onclose = function (e) {
    close();
  }
}

function _encrypt(k, s) {
  return 'encrypted-' + k + ' ' + s;
}</pre>

  <p>For decrypting:

  <pre>onmessage = function (e) {
  var key = e.data;
  e.port.onmessage = function (e) {
    var s = e.data;
    postMessage(_decrypt(key, s));
  }
  e.port.onclose = function (e) {
    close();
  }
}

function _decrypt(k, s) {
  return s.substr(s.indexOf(' ')+1);
}</pre>

  <p>Notice how the users of the API don't have to even know that this is
   happening &mdash; the API hasn't changed; the library can delegate to
   subworkers without changing its API, even though it is accepting data
   using message channels.

  <p><a href="http://www.whatwg.org/demos/workers/crypto/page.html">View this
   example online</a>.

  <h3 id=conformance><span class=secno>1.3 </span>Conformance requirements</h3>

  <p>All diagrams, examples, and notes in this specification are
   non-normative, as are all sections explicitly marked non-normative.
   Everything else in this specification is normative.

  <p>The key words "MUST", "MUST NOT", "REQUIRED", <!--"SHALL", "SHALL
  NOT",-->
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in the
   normative parts of this document are to be interpreted as described in
   RFC2119. For readability, these words do not appear in all uppercase
   letters in this specification. <a href="#refsRFC2119">[RFC2119]</a>

  <p>Requirements phrased in the imperative as part of algorithms (such as
   "strip any leading space characters" or "return false and abort these
   steps") are to be interpreted with the meaning of the key word ("must",
   "should", "may", etc) used in introducing the algorithm.

  <p>Some conformance requirements are phrased as requirements on attributes,
   methods or objects. Such requirements are to be interpreted as
   requirements on user agents.

  <p>Conformance requirements phrased as algorithms or specific steps may be
   implemented in any manner, so long as the end result is equivalent. (In
   particular, the algorithms defined in this specification are intended to
   be easy to follow, and not intended to be performant.)

  <p>The only conformance class defined by this specification is user agents.

  <p>User agents may impose implementation-specific limits on otherwise
   unconstrained inputs, e.g. to prevent denial of service attacks, to guard
   against running out of memory, or to work around platform-specific
   limitations.

  <h4 id=dependencies><span class=secno>1.3.1 </span>Dependencies</h4>

  <p>This specification relies on several other underlying specifications.

  <dl>
   <dt>HTML5

   <dd>
    <p>Many fundamental concepts from HTML5 are used by this specification.
     <a href="#refsHTML5">[HTML5]</a></p>

   <dt>ECMAScript

   <dd>
    <p>This specification is intended to be used with JavaScript as the
     scripting language. <a href="#refsJS">[JS]</a></p>

   <dt>WebIDL

   <dd>
    <p>The IDL blocks in this specification use the semantics of the WebIDL
     specification. <a href="#refsWebIDL">[WebIDL]</a></p>
  </dl>

  <h3 id=terminology><span class=secno>1.4 </span>Terminology</h3>

  <p>The construction "a <code title="">Foo</code> object", where <code
   title="">Foo</code> is actually an interface, is sometimes used instead of
   the more accurate "an object implementing the interface <code
   title="">Foo</code>".

  <p>The term DOM is used to refer to the API set made available to scripts
   in Web applications, and does not necessarily imply the existence of an
   actual <code>Document</code> object or of any other <code>Node</code>
   objects as defined in the DOM Core specifications. <a
   href="#refsDOM3CORE">[DOM3CORE]</a>

  <p>A DOM attribute is said to be <em>getting</em> when its value is being
   retrieved (e.g. by author script), and is said to be <em>setting</em> when
   a new value is assigned to it.

  <h2 id=infrastructure><span class=secno>2. </span>Infrastructure</h2>

  <p>There are two kinds of workers; dedicated workers, and shared workers.
   Dedicated workers, once created, and are linked to their creator; but
   message ports can be used to communicate from a dedicated worker to
   multiple other browsing contexts or workers. Shared workers, on the other
   hand, are named, and once created any script running in the same
   <span>origin</span> can obtain a reference to that worker and communicate
   with it.

  <h3 id=the-global><span class=secno>2.1 </span>The global scope</h3>

  <p>The global scope is the "inside" of a worker.

  <h4 id=the-workerglobalscope><span class=secno>2.1.1 </span>The <code><a
   href="#workerglobalscope">WorkerGlobalScope</a></code> abstract interface</h4>

  <pre
   class=idl>[NoInterfaceObject] interface <dfn id=workerglobalscope>WorkerGlobalScope</dfn> {
  readonly attribute <a href="#workerglobalscope">WorkerGlobalScope</a> <a href="#self" title=dom-WorkerGlobalScope-self>self</a>;
  readonly attribute <a href="#workerlocation">WorkerLocation</a> <a href="#location" title=dom-WorkerGlobalScope-location>location</a>;
  // also implements everything on <a href="#workerutils">WorkerUtils</a>

  void <a href="#close" title=dom-WorkerGlobalScope-close>close</a>();
           attribute <span>EventListener</span> <a href="#onclose" title=handler-WorkerGlobalScope-onclose>onclose</a>;
};</pre>

  <p>Objects implementing the <code><a
   href="#workerglobalscope">WorkerGlobalScope</a></code> interface must also
   implement the <code>EventTarget</code> interface.

  <p>The <dfn id=self
   title=dom-WorkerGlobalScope-self><code>self</code></dfn> attribute must
   return the <code><a href="#workerglobalscope">WorkerGlobalScope</a></code>
   object itself.

  <p>The <dfn id=location
   title=dom-WorkerGlobalScope-location><code>location</code></dfn> attribute
   must return the <code><a href="#workerlocation">WorkerLocation</a></code>
   object created for the <code><a
   href="#workerglobalscope">WorkerGlobalScope</a></code> object when the
   worker was created. It represents the <span>absolute URL</span> of the
   script that was used to initialize the worker.

  <hr>

  <p>When a script invokes the <dfn id=close
   title=dom-WorkerGlobalScope-close><code>close()</code></dfn> method on a
   <code><a href="#workerglobalscope">WorkerGlobalScope</a></code> object,
   the user agent must run the following steps:

  <ol>
   <li>
    <p><span>Queue a task</span> to <span>fire a simple event</span> called
     <code title=event-close>close</code> at the <code><a
     href="#workerglobalscope">WorkerGlobalScope</a></code> object.

   <li>
    <p>Set the worker's <code><a
     href="#workerglobalscope">WorkerGlobalScope</a></code> object's <a
     href="#closing" title=dom-WorkerGlobalScope-closing>closing</a> flag to
     true.

   <li>
    <p>For each <code>MessagePort</code> object that is entangled with
     another port and that has one (but only one) port whose owner is the
     <code><a href="#workerglobalscope">WorkerGlobalScope</a></code> object
     on which the method was invoked (this would include, for instance, the
     implicit port in used for dedicated workers), unentangle the two ports.
  </ol>

  <p>The following are the <span>event handler DOM attributes</span> that
   must be supported by objects implementing the <code><a
   href="#workerglobalscope">WorkerGlobalScope</a></code> interface:

  <dl>
   <dt><dfn id=onclose
    title=handler-WorkerGlobalScope-onclose><code>onclose</code></dfn>

   <dd>
    <p>Must be invoked whenever a <code title=event-close>close</code> event
     is targeted at or bubbles through the <code><a
     href="#workerglobalscope">WorkerGlobalScope</a></code> object.
  </dl>

  <h4 id=dedicated><span class=secno>2.1.2 </span>Dedicated workers and the
   <code><a
   href="#dedicatedworkerglobalscope">DedicatedWorkerGlobalScope</a></code>
   interface</h4>

  <pre
   class=idl>[NoInterfaceObject] interface <dfn id=dedicatedworkerglobalscope>DedicatedWorkerGlobalScope</dfn> : <a href="#workerglobalscope">WorkerGlobalScope</a> {
  void <a href="#postmessage" title=dom-DedicatedWorkerGlobalScope-postMessage>postMessage</a>(in DOMString message);
  void <a href="#postmessage" title=dom-DedicatedWorkerGlobalScope-postMessage>postMessage</a>(in DOMString message, in <span>MessagePort</span> messagePort);<!--
  <span>MessagePort</span> <span title="dom-DedicatedWorkerGlobalScope-startConversation">startConversation</span>(in DOMString message);-->
           attribute <span>EventListener</span> <a href="#onmessage" title=handler-DedicatedWorkerGlobalScope-onmessage>onmessage</a>;
};</pre>

  <p><code><a
   href="#dedicatedworkerglobalscope">DedicatedWorkerGlobalScope</a></code>
   objects act as if they had an implicit <code>MessagePort</code> associated
   with them. This port is part of a channel that is set up when the worker
   is created, but it is not exposed. This object must never be garbage
   collected before the <code><a
   href="#dedicatedworkerglobalscope">DedicatedWorkerGlobalScope</a></code>
   object.

  <p>All messages received by that port must immediately be retargetted at
   the <code><a
   href="#dedicatedworkerglobalscope">DedicatedWorkerGlobalScope</a></code>
   object.

  <p>The <dfn id=postmessage
   title=dom-DedicatedWorkerGlobalScope-postMessage><code>postMessage()</code></dfn><!--
  and <dfn
  title="dom-DedicatedWorkerGlobalScope-startConversation"><code>startConversation()</code></dfn>-->
   method<!--s (startConversation)--> on <code><a
   href="#dedicatedworkerglobalscope">DedicatedWorkerGlobalScope</a></code>
   objects must act as if, when invoked, it<!--/they (startConversation)-->
   immediately invoked the method of the same name on the port, with the same
   arguments, and returned the same return value.

  <p>The following are the <span>event handler DOM attributes</span> that
   must be supported by objects implementing the <code><a
   href="#dedicatedworkerglobalscope">DedicatedWorkerGlobalScope</a></code>
   interface:

  <dl>
   <dt><dfn id=onmessage
    title=handler-DedicatedWorkerGlobalScope-onmessage><code>onmessage</code></dfn>

   <dd>
    <p>Must be invoked whenever a <code
     title=event-DedicatedWorkerGlobalScope-message>message</code> event is
     targeted at or bubbles through the <code><a
     href="#dedicatedworkerglobalscope">DedicatedWorkerGlobalScope</a></code>
     object.
  </dl>

  <h4 id=shared0><span class=secno>2.1.3 </span>Shared workers and the
   <code><a
   href="#sharedworkerglobalscope">SharedWorkerGlobalScope</a></code>
   inteface</h4>

  <pre
   class=idl>[NoInterfaceObject] interface <dfn id=sharedworkerglobalscope>SharedWorkerGlobalScope</dfn> : <a href="#workerglobalscope">WorkerGlobalScope</a> {
  readonly attribute DOMString <a href="#name" title=dom-SharedWorkerGlobalScope-name>name</a>;
           attribute <span>EventListener</span> <a href="#onconnect" title=handler-SharedWorkerGlobalScope-onconnect>onconnect</a>;
};</pre>

  <p>Shared workers receive message ports through <code
   title=event-WorkerGlobalScope-connect>connect</code> events on their
   global object for each connection.

  <p>The <dfn id=name
   title=dom-SharedWorkerGlobalScope-name><code>name</code></dfn> attribute
   must return the value it was assigned when the <code><a
   href="#sharedworkerglobalscope">SharedWorkerGlobalScope</a></code> object
   was created by the "<a href="#run-a">run a worker</a>" algorithm. Its
   value represents the name that can be used to obtain a reference to the
   worker using the <code><a href="#sharedworker">SharedWorker</a></code>
   constructor.

  <p>The following are the <span>event handler DOM attributes</span> that
   must be supported by objects implementing the <code><a
   href="#sharedworkerglobalscope">SharedWorkerGlobalScope</a></code>
   interface:

  <dl>
   <dt><dfn id=onconnect
    title=handler-SharedWorkerGlobalScope-onconnect><code>onconnect</code></dfn>

   <dd>
    <p>Must be invoked whenever a <code
     title=event-SharedWorkerGlobalScope-connect>connect</code> event is
     targeted at or bubbles through the <code><a
     href="#sharedworkerglobalscope">SharedWorkerGlobalScope</a></code>
     object.
  </dl>

  <h3 id=base-urls><span class=secno>2.2 </span>Base URLs and origins of
   workers</h3>

  <p>Both the <span>origin</span> and <span>effective script origin</span> of
   scripts running in workers are the <span>origin</span> of the
   <span>absolute URL</span> given in that the worker's <code
   title=dom-WorkerGlobalScope-location><a
   href="#location">location</a></code> attribute represents.

  <h3 id=the-event><span class=secno>2.3 </span>The event loop</h3>

  <p>Each <code><a href="#workerglobalscope">WorkerGlobalScope</a></code>
   object is asssociated with a <span>event loop</span>. This <span>event
   loop</span> has no associated <span>browsing context</span>, and its <span
   title="task queue">task queues</span> only have events, callbacks, and
   networking activity as <span title=concept-task>tasks</span>. The
   processing model of these <span title="event loop">event loops</span> is
   defined below in the <a href="#run-a">run a worker</a> algorithm.

  <p>Each <code><a href="#workerglobalscope">WorkerGlobalScope</a></code>
   object also has a <dfn id=closing
   title=dom-WorkerGlobalScope-closing>closing</dfn> flag, which must
   initially be false, but which can get set to true by the algorithms in the
   processing model section below.

  <p>Once the <code><a
   href="#workerglobalscope">WorkerGlobalScope</a></code>'s <a
   href="#closing" title=dom-WorkerGlobalScope-closing>closing</a> flag is
   set to true, the <span>event loop</span>'s <span title="task queue">task
   queues</span> must discard any further <span
   title=concept-task>tasks</span> that would be added to them (tasks already
   on the queue are unaffected unless otherwise specified). Effectively, once
   the <a href="#closing" title=dom-WorkerGlobalScope-closing>closing</a>
   flag is true, timers stop firing, notifications for all pending
   asynchronous operations are dropped, etc.

  <h3 id=the-workers><span class=secno>2.4 </span>The worker's ports</h3>

  <p>Workers communicate with other workers and with <span title="browsing
   context">browsing contexts</span> through <span title="channel
   messaging">message channels</span> and their <code>MessagePort</code>
   objects.

  <p>Each <code><a href="#workerglobalscope">WorkerGlobalScope</a></code>
   <var title="">worker global scope</var> has a list of <dfn
   id=the-workers0>the worker's ports</dfn>, which consists of all the
   <code>MessagePort</code> objects that are entangled with another port and
   that have one (but only one) port owned by <var title="">worker global
   scope</var>. This list includes
   <!--all the <code>MessagePort</code> objects that are in events
  pending in the <span>event loop</span>, as well as (commented out
  because in practice it makes no difference either way as far as I
  can tell, and it would be hard to strictly implement since these
  ports might not yet be across the thread boundary)-->
   the implicit <code>MessagePort</code> in the case of <a
   href="#dedicatedworkerglobalscope"
   title=DedicatedWorkerGlobalScope>dedicated workers</a>.

  <hr>

  <p>A worker is said to be a <dfn id=permissible>permissible worker</dfn> if
   either:

  <ul>
   <li>at some point past or present a <code>MessagePort</code> owned by the
    worker was entangled with a <code>MessagePort</code> <var
    title="">p</var> whose owner is a <code>Window</code> object whose
    <span>active document</span> is the <code>Document</code> that was that
    <span>browsing context</span>'s <span>active document</span> when <var
    title="">p</var> was created, and that <code>Document</code> is
    <span>fully active</span>, or

   <li>at some point past or present a <code>MessagePort</code> owned by the
    worker was entangled with a <code>MessagePort</code> owned by another
    worker that is currently a <a href="#permissible">permissible worker</a>.
  </ul>

  <hr>

  <p>A worker is said to be a <dfn id=protected>protected worker</dfn> if
   either:

  <ul>
   <li>it has outstanding timers, database transactions, or network
    connections, and is a <a href="#permissible">permissible worker</a>, or

   <li>there is a <a href="#protected">protected worker</a> that at some
    point past or present owned a <code>MessagePort</code> that was entangled
    with a <code>MessagePort</code> owned by this worker.
  </ul>

  <hr>

  <p>A worker is said to be an <dfn id=active>active needed worker</dfn> if
   either:

  <ul>
   <li>the worker is a <a href="#protected">protected worker</a>, or

   <li>at least one of the <a href="#the-workers0">the worker's ports</a> is
    entangled with a <code>MessagePort</code> <var title="">p</var> whose
    owner is a <code>Window</code> object whose <span>active document</span>
    is the <code>Document</code> that was that <span>browsing
    context</span>'s <span>active document</span> when that
    <code>MessagePort</code> <var title="">p</var> was created, and that
    <code>Document</code> is <span>fully active</span>, or

   <li>at least one of the <a href="#the-workers0">the worker's ports</a> has
    an entangled <code>MessagePort</code> owned by a <code><a
    href="#workerglobalscope">WorkerGlobalScope</a></code> object that is
    itself an <a href="#active">active needed worker</a>.
  </ul>

  <hr>

  <p>A worker is said to be a <dfn id=suspendable>suspendable worker</dfn> if
   it is not an <a href="#active">active needed worker</a> but either:

  <ul>
   <li>at least one of the <a href="#the-workers0">the worker's ports</a> has
    an entangled <code>MessagePort</code> owned by a <code>Window</code>
    object, or

   <li>at least one of the <a href="#the-workers0">the worker's ports</a> has
    an entangled <code>MessagePort</code> owned by a <code><a
    href="#workerglobalscope">WorkerGlobalScope</a></code> object that is
    itself a <span>needed worker</span>.
  </ul>

  <h3 id=processing><span class=secno>2.5 </span>Processing model</h3>

  <p>When a user agent is to <dfn id=run-a>run a worker</dfn> for a script
   with <span>URL</span> <var title="">url</var>, a browsing context <var
   title="">owner browsing context</var>, and with global scope <var
   title="">worker global scope</var>, it must run the following steps:

  <ol>
   <li>
    <p>Create a completely separate and parallel execution environment (i.e.
     a separate thread or process or equivalent construct), and run the rest
     of these steps asychronously in that context.</p>

   <li>
    <p>Attempt to <span>fetch</span> the resource identified by <var
     title="">url</var>.</p>

    <p>If the attempt fails, then for each <code><a
     href="#worker1">Worker</a></code> or <code><a
     href="#sharedworker">SharedWorker</a></code> object associated with <var
     title="">worker global scope</var>, <span>queue a task</span> to
     <span>fire a simple event</span> called <code
     title=event-error>error</code> at that object. Abort these steps.</p>

    <p>If the attempt succeeds, then let <var title="">source</var> be the
     text of the resource that was obtained.</p>
    <!-- XXX do we need
    to define character encoding decoding here? -->
    <p>Let <var title="">language</var> be JavaScript.</p>

    <p class=note>As with <code>script</code> elements, the MIME type of the
     script is ignored. Unlike with <code>script</code> elements, there is no
     way to override the type. It's always assumed to be JavaScript.</p>
    <!-- XXX people will complain about
    this. I guess we might want to examine the MIME type... -->
    

   <li>
    <p>A new <span title=concept-script>script</span> is now created, as
     follows.</p>

    <p>Create a new <span>script execution environment</span> set up as
     appropriate for the scripting language <var title="">language</var>.</p>

    <p>Parse/compile/initialize <var title="">source</var> using that
     <span>script execution environment</span>, as appropriate for <var
     title="">language</var>, and thus obtain a <span>list of code
     entry-points</span>; set the <i>initial code entry-point</i> to the
     entry-point for any executable code to be immediately run.</p>

    <p>Set the <span>script's global object</span> to <var title="">worker
     global scope</var>.</p>

    <p>Set the <span>script's browsing context</span> to <var title="">owner
     browsing context</var>.</p>

    <p>Set the <span>script's character encoding</span> to UTF-8. (This is
     just used for encoding non-ASCII characters in the query component of
     URLs.)</p>

    <p>Set the <span>script's base URL</span> to <var title="">url</var>.</p>

    <p>Create a new <span>script group</span> and add the <span
     title=concept-script>script</span> to it.</p>

   <li>
    <p><strong>Closing orphan workers</strong>: Start monitoring the worker
     such that as soon as it stops being either an <a href="#active">active
     needed worker</a> or a <a href="#suspendable">suspendable worker</a>,
     <var title="">worker global scope</var>'s <a href="#closing"
     title=dom-WorkerGlobalScope-closing>closing</a> flag is set to true and
     <span title="queue a task">a task is queued</span> to <span>fire a
     simple event</span> called <code title=event-close>close</code> at <var
     title="">worker global scope</var>.</p>

   <li>
    <p><strong>Suspending workers</strong>: Start monitoring the worker, such
     that whenever <var title="">worker global scope</var>'s <a
     href="#closing" title=dom-WorkerGlobalScope-closing>closing</a> flag is
     false and the worker is a <a href="#suspendable">suspendable worker</a>,
     the user agent suspends execution of script in that worker until such
     time as either the <a href="#closing"
     title=dom-WorkerGlobalScope-closing>closing</a> flag switches to true or
     the worker stops being a <a href="#suspendable">suspendable worker</a>.</p>

   <li>
    <p><span title="jump to a code entry-point">Jump</span> to the <span
     title=concept-script>script</span>'s <i>initial code entry-point</i>,
     and let that run until it either returns, fails to catch an exception,
     or gets prematurely aborted by the "<a href="#kill-a">kill a worker</a>"
     or "<a href="#terminate">terminate a worker</a>" algorithms defined
     below.</p>

    <p class=note>If the script gets aborted by the "<a href="#kill-a">kill a
     worker</a>" algorithm, then that same algorithm will cause there to only
     be a single <span title=concept-task>task</span> in the <span>event
     loop</span> at the next step, namely the task for the <code
     title=message-close>close</code> event. The "<a
     href="#terminate">terminate a worker</a>" algorithm removes all the
     events.</p>

   <li>
    <p><i title="">Event loop</i>: Wait until either there is a <span
     title=concept-task>task</span> in one of the <span>event loop</span>'s
     <span title="task queue">task queues</span> or <var title="">worker
     global scope</var>'s <a href="#closing"
     title=dom-WorkerGlobalScope-closing>closing</a> flag is set to true.</p>

   <li>
    <p>Run the oldest task on one of the <span>event loop</span>'s <span
     title="task queue">task queues</span>, if any. The user agent may pick
     any <span>task queue</span>.</p>

    <p class=note>The handling of events or the execution of callbacks might
     get prematurely aborted by the "<a href="#kill-a">kill a worker</a>" or
     "<a href="#terminate">terminate a worker</a>" algorithms defined below.</p>

   <li>
    <p>Remove the task run in the previous step, if any, from its <span>task
     queue</span>.</p>

   <li>
    <p>If there are any more events in the <span>event loop</span>'s <span
     title="task queue">task queues</span> or if <var title="">worker global
     scope</var>'s <a href="#closing"
     title=dom-WorkerGlobalScope-closing>closing</a> flag is set to false,
     then jump back to the step above labeled <i>event loop</i>.</p>

   <li>
    <p>Freeze the <span>script group</span>.</p>

    <p class=note>This kills timers, database transactions, etc.</p>

   <li>
    <p>For each <code><a href="#worker1">Worker</a></code> or <code><a
     href="#sharedworker">SharedWorker</a></code> object associated with <var
     title="">worker global scope</var>, <span>queue a task</span> to
     <span>fire a simple event</span> called <code
     title=event-close>close</code> at that object.</p>
  </ol>

  <hr>

  <p>When a user agent is to <dfn id=kill-a>kill a worker</dfn> it must run
   the following steps in parallel with the worker's main loop (the "<a
   href="#run-a">run a worker</a>" processing model defined above):

  <ol>
   <li>
    <p>If the worker's <code><a
     href="#workerglobalscope">WorkerGlobalScope</a></code> object's <a
     href="#closing" title=dom-WorkerGlobalScope-closing>closing</a> flag is
     false, <span>queue a task</span> to <span>fire a simple event</span>
     called <code title=event-close>close</code> at the worker's <code><a
     href="#workerglobalscope">WorkerGlobalScope</a></code> object.

   <li>
    <p>Set the worker's <code><a
     href="#workerglobalscope">WorkerGlobalScope</a></code> object's <a
     href="#closing" title=dom-WorkerGlobalScope-closing>closing</a> flag to
     true.

   <li>
    <p>Wait a user-agent-defined amount of time. If the "<a href="#run-a">run
     a worker</a>" processing model defined above immediately starts running
     event listeners registered for the <code title=event-close>close</code>
     event, this time should not be zero &mdash; the idea is that the <code
     title=event-close>close</code> event can be used to clean up when
     shutting down unexpectedly.

   <li>
    <p>If there are any <span title=concept-task>tasks</span> queued in the
     <span>event loop</span>'s <span title="task queue">task queues</span>
     other than the <code title=event-close>close</code> event that this
     algorithm just added, discard them without processing them.

   <li>
    <p>If the <code title=event-close>close</code> event that this algorithm
     just queued hasn't yet been dispatched, then abort the script currently
     running in the worker.

   <li>
    <p>Wait a user-agent-defined amount of time.

   <li>
    <p>Abort the script currently running in the worker (if any script is
     running, then it will be a handler for the <code
     title=event-close>close</code> event).
  </ol>

  <p>User agents may invoke the "<a href="#kill-a">kill a worker</a>"
   processing model on a worker at any time, e.g. in response to user
   requests, in response to CPU quota management, or when a worker stops
   being an <a href="#active">active needed worker</a> if the worker
   continues executing even after its <a href="#closing"
   title=dom-WorkerGlobalScope-closing>closing</a> flag was set to true.

  <hr>

  <p>When a user agent is to <dfn id=terminate>terminate a worker</dfn> it
   must run the following steps in parallel with the worker's main loop (the
   "<a href="#run-a">run a worker</a>" processing model defined above):

  <ol>
   <li>
    <p>Set the worker's <code><a
     href="#workerglobalscope">WorkerGlobalScope</a></code> object's <a
     href="#closing" title=dom-WorkerGlobalScope-closing>closing</a> flag to
     true.

   <li>
    <p>If there are any <span title=concept-task>tasks</span> queued in the
     <span>event loop</span>'s <span title="task queue">task queues</span>,
     discard them without processing them.

   <li>
    <p>Abort the script currently running in the worker.

   <li>
    <p>If the worker's <code><a
     href="#workerglobalscope">WorkerGlobalScope</a></code> object is
     actually a <code><a
     href="#dedicatedworkerglobalscope">DedicatedWorkerGlobalScope</a></code>
     object (i.e. the worker is a dedicated worker), then empty the
     <span>port message queue</span> of the port that the worker's implicit
     port is entangled with.
  </ol>

  <h3 id=creating><span class=secno>2.6 </span>Creating workers</h3>

  <h4 id=the-abstractworker><span class=secno>2.6.1 </span>The <code><a
   href="#abstractworker">AbstractWorker</a></code> abstract interface</h4>

  <pre
   class=idl>[NoInterfaceObject] interface <dfn id=abstractworker>AbstractWorker</dfn> {
           attribute <span>EventListener</span> <a href="#onerror" title=handler-AbstractWorker-onerror>onerror</a>;
           attribute <span>EventListener</span> <a href="#onclose0" title=handler-AbstractWorker-onclose>onclose</a>;
};</pre>

  <p>Objects implementing the <code><a
   href="#abstractworker">AbstractWorker</a></code> interface must also
   implement the <code>EventTarget</code> interface.

  <p>The following are the <span>event handler DOM attributes</span> that
   must be supported by objects implementing the <code><a
   href="#abstractworker">AbstractWorker</a></code> interface:

  <dl>
   <dt><dfn id=onerror
    title=handler-AbstractWorker-onerror><code>onerror</code></dfn>

   <dd>
    <p>Must be invoked whenever an <code title=event-error>error</code> event
     is targeted at or bubbles through the <code><a
     href="#abstractworker">AbstractWorker</a></code> object.

   <dt><dfn id=onclose0
    title=handler-AbstractWorker-onclose><code>onclose</code></dfn>

   <dd>
    <p>Must be invoked whenever an <code title=event-close>close</code> event
     is targeted at or bubbles through the <code><a
     href="#abstractworker">AbstractWorker</a></code> object.
  </dl>

  <h4 id=dedicated0><span class=secno>2.6.2 </span>Dedicated workers and the
   <code><a href="#worker1">Worker</a></code> interface</h4>

  <pre class=idl>[NoInterfaceObject,
 <a href="#worker2" title=dom-Worker>Constructor</a>(in DOMString scriptURL)]
interface <dfn id=worker1>Worker</dfn> : <a href="#abstractworker">AbstractWorker</a> {
  void <a href="#terminate0" title=dom-Worker-terminate>terminate</a>();

  void <a href="#postmessage0" title=dom-Worker-postMessage>postMessage</a>(in DOMString message);
  void <a href="#postmessage0" title=dom-Worker-postMessage>postMessage</a>(in DOMString message, in <span>MessagePort</span> messagePort);<!--
  <span>MessagePort</span> <span title="dom-Worker-startConversation">startConversation</span>(in DOMString message);-->
           attribute <span>EventListener</span> <a href="#onmessage0" title=handler-Worker-onmessage>onmessage</a>;
};</pre>

  <p>The <dfn id=terminate0
   title=dom-Worker-terminate><code>terminate()</code></dfn> method, when
   invoked, must cause the "<a href="#terminate">terminate a worker</a>"
   algorithm to be run on the worker with with the object is associated.

  <p><code><a href="#worker1">Worker</a></code> objects act as if they had an
   implicit <code>MessagePort</code> associated with them. This port is part
   of a channel that is set up when the worker is created, but it is not
   exposed. This object must never be garbage collected before the <code><a
   href="#worker1">Worker</a></code> object.

  <p>All messages received by that port must immediately be retargetted at
   the <code><a href="#worker1">Worker</a></code> object.

  <p>The <dfn id=postmessage0
   title=dom-Worker-postMessage><code>postMessage()</code></dfn><!--
  and <dfn
  title="dom-Worker-startConversation"><code>startConversation()</code></dfn>-->
   method<!--s (startConversation)--> on <code><a
   href="#worker1">Worker</a></code> objects must act as if, when invoked,
   it<!--/they (startConversation)--> immediately invoked the method of the
   same name on the port, with the same arguments, and returned the same
   return value.

  <p>The following are the <span>event handler DOM attributes</span> that
   must be supported by objects implementing the <code><a
   href="#worker1">Worker</a></code> interface:

  <dl>
   <dt><dfn id=onmessage0
    title=handler-Worker-onmessage><code>onmessage</code></dfn>

   <dd>
    <p>Must be invoked whenever a <code
     title=event-Worker-message>message</code> event is targeted at or
     bubbles through the <code><a href="#worker1">Worker</a></code> object.
  </dl>

  <hr>

  <p>When the <dfn id=worker2 title=dom-Worker><code>Worker(<var
   title="">scriptURL</var>)</code></dfn> constructor is invoked, the user
   agent must run the following steps:

  <ol>
   <li>
    <p><span title="resolve a url">Resolve</span> the <var
     title="">scriptURL</var> argument.

   <li>
    <p>If this fails, throw a <code>SYNTAX_ERR</code> exception.

   <li>
    <p>If the <span>origin</span> of the resulting <span>absolute URL</span>
     is not the <span title="same origin">same</span> as the origin of the
     script that invoked the constructor, then throw a <span>security
     exception</span>.

   <li>
    <p><span>Create a new <code><a
     href="#dedicatedworkerglobalscope">DedicatedWorkerGlobalScope</a></code>
     object</span>. Let <var title="">worker global scope</var> be this new
     object.

   <li>
    <p>Create a new <code><a href="#worker1">Worker</a></code> object,
     associated with <var title="">worker global scope</var>. Let <var
     title="">worker</var> be this new object.

   <li>
    <p><span>Create a <code>MessagePort</code> object</span> owned by the
     <span>script execution context</span> of the script that invoked the
     method. Let this be the <var title="">outside port</var>.

   <li>
    <p>Associate the <var title="">outside port</var> with <var
     title="">worker</var>.

   <li>
    <p><span>Create a <code>MessagePort</code> object</span> owned by <var
     title="">worker global scope</var>. Let <var title="">inside port</var>
     be this new object.

   <li>
    <p>Associate <var title="">inside port</var> with <var title="">worker
     global scope</var>.

   <li>
    <p><span>Entangle</span> <var title="">outside port</var> and <var
     title="">inside port</var>.

   <li>
    <p>Return <var title="">worker</var>, and run the following steps
     asynchronously.

   <li>
    <p>Open <var title="">inside port</var>'s <span>port message
     queue</span>.

   <li>
    <p>Open <var title="">outside port</var>'s <span>port message
     queue</span>.

   <li>
    <p><a href="#run-a">Run a worker</a> for the resulting <span>absolute
     URL</span>, with the <span>script browsing context</span> of the script
     that invoked the method as the <var title="">owner browsing
     context</var>, and with <var title="">worker global scope</var> as the
     global scope.</p>
  </ol>

  <h4 id=shared1><span class=secno>2.6.3 </span>Shared workers and the
   <code><a href="#sharedworker">SharedWorker</a></code> interface</h4>

  <pre class=idl>[NoInterfaceObject,
 <a href="#sharedworker0" title=dom-SharedWorker>Constructor</a>(in DOMString scriptURL, in DOMString name)]
interface <dfn id=sharedworker>SharedWorker</dfn> : <a href="#abstractworker">AbstractWorker</a> {
  readonly attribute <code>MessagePort</code> <a href="#port" title=dom-SharedWorker-port>port</a>;
};</pre>

  <p>The <dfn id=port title=dom-SharedWorker-port><code>port</code></dfn>
   attribute must return the value it was assigned by the object's
   constructor. It represents the <code>MessagePort</code> for communicating
   with the shared worker.

  <p>When the <dfn id=sharedworker0
   title=dom-SharedWorker><code>SharedWorker(<var title="">scriptURL</var>,
   <var title="">name</var>)</code></dfn> constructor is invoked, the user
   agent must run the following steps:

  <ol>
   <li>
    <p><span title="resolve a url">Resolve</span> the <var
     title="">scriptURL</var> argument.

   <li>
    <p>If this fails, throw a <code>SYNTAX_ERR</code> exception.

   <li>
    <p>If the <span>origin</span> of the resulting <span>absolute URL</span>
     is not the <span title="same origin">same</span> as the origin of the
     script that invoked the constructor, then throw a <span>security
     exception</span>.

   <li>
    <p>Execute the following substeps atomically:</p>

    <ol>
     <li>
      <p>Create a new <code><a href="#sharedworker">SharedWorker</a></code>
       object, which will shortly be associated with a <code><a
       href="#sharedworkerglobalscope">SharedWorkerGlobalScope</a></code>
       object. Let this <code><a href="#sharedworker">SharedWorker</a></code>
       object be <var title="">worker</var>.

     <li>
      <p><span>Create a <code>MessagePort</code> object</span> owned by the
       <span>script execution context</span> of the script that invoked the
       method. Let this be the <var title="">outside port</var>.

     <li>
      <p>Assign <var title="">outside port</var> to the <code
       title=dom-SharedWorker-port><a href="#port">port</a></code> attribute
       of <var title="">worker</var>.

     <li>
      <p>If there exists a <code><a
       href="#sharedworkerglobalscope">SharedWorkerGlobalScope</a></code>
       object whose <a href="#closing"
       title=dom-WorkerGlobalScope-closing>closing</a> flag is false, whose
       <code title=dom-WorkerGlobalScope-name>name</code> attribute is
       exactly equal to the <var title="">name</var> argument, and whose
       <code title=dom-WorkerGlobalScope-location><a
       href="#location">location</a></code> attribute represents an
       <span>absolute URL</span> that has the <span>same origin</span> as the
       resulting <span>absolute URL</span>, then run these substeps:</p>

      <ol>
       <li>
        <p>Let <var title="">worker global scope</var> be that <code><a
         href="#sharedworkerglobalscope">SharedWorkerGlobalScope</a></code>
         object.

       <li>
        <p>If <var title="">worker global scope</var>'s <code
         title=dom-WorkerGlobalScope-location><a
         href="#location">location</a></code> attribute represents an
         <span>absolute URL</span> that is not exactly equal to the resulting
         <span>absolute URL</span>, then throw a
         <code>URL_MISMATCH_ERR</code> exception and abort all these steps.
         <span class=big-issue>code 21</span>

       <li>
        <p>Associate <var title="">worker</var> with <var title="">worker
         global scope</var>.

       <li>
        <p><span>Create a <code>MessagePort</code> object</span> owned by
         <var title="">worker global scope</var>. Let this be the <var
         title="">inside port</var>.

       <li>
        <p><span>Entangle</span> <var title="">outside port</var> and <var
         title="">inside port</var>.

       <li>
        <p>Return <var title="">worker</var> and perform the next step
         asynchronously.

       <li>
        <p>Create an event that uses the <code>MessageEvent</code> interface,
         with the name <code title=event-connect>connect</code>, which does
         not bubble, is cancelable, has no default action, has a <code
         title=dom-MessageEvent-data>data</code> attribute whose value is the
         empty string and has a <code
         title=dom-MessageEvent-messagePort>messagePort</code> attribute
         whose value is the newly created port, and <span>queue a task</span>
         to dispatch the event at <var title="">worker global scope</var>.

       <li>
        <p>Abort all these steps.
      </ol>

     <li>
      <p><span>Create a new <code><a
       href="#sharedworkerglobalscope">SharedWorkerGlobalScope</a></code>
       object</span>. Let <var title="">worker global scope</var> be this new
       object.

     <li>
      <p>Associate <var title="">worker</var> with <var title="">worker
       global scope</var>.

     <li>
      <p>Set the <code title=dom-SharedWorkerGlobalScope-name><a
       href="#name">name</a></code> attribute of <var title="">worker global
       scope</var> to <var title="">name</var>.

     <li>
      <p><span>Create a <code>MessagePort</code> object</span> owned by <var
       title="">worker global scope</var>. Let <var title="">inside
       port</var> be this new object.

     <li>
      <p><span>Entangle</span> <var title="">outside port</var> and <var
       title="">inside port</var>.
    </ol>

   <li>
    <p>Return <var title="">worker</var> and perform the next step
     asynchronously.

   <li>
    <p>Create an event that uses the <code>MessageEvent</code> interface,
     with the name <code title=event-connect>connect</code>, which does not
     bubble, is cancelable, has no default action, has a <code
     title=dom-MessageEvent-data>data</code> attribute whose value is the
     empty string and has a <code
     title=dom-MessageEvent-messagePort>messagePort</code> attribute whose
     value is the newly created port, and <span>queue a task</span> to
     dispatch the event at <var title="">worker global scope</var>.

   <li>
    <p><a href="#run-a">Run a worker</a> for the resulting <span>absolute
     URL</span>, with the <span>script browsing context</span> of the script
     that invoked the method as the <var title="">owner browsing
     context</var>, and with <var title="">worker global scope</var> as the
     global scope.</p>
  </ol>

  <h2 id=apis-available><span class=secno>3. </span>APIs available to workers</h2>

  <pre
   class=idl>[NoInterfaceObject] interface <dfn id=workerutils>WorkerUtils</dfn> {
  void <a href="#importscripts" title=dom-WorkerGlobalScope-importScripts>importScripts</a>([Variadic] in DOMString urls);
  readonly attribute <span>Storage</span> <a href="#localstorage" title=dom-localStorage>localStorage</a>;
  readonly attribute <a href="#navigator0">Navigator</a> <a href="#navigator" title=dom-navigator>navigator</a>;
  <span>Database</span> <a href="#opendatabase" title=dom-opendatabase>openDatabase</a>(in DOMString name, in DOMString version, in DOMString displayName, in unsigned long estimatedSize);
  void <a href="#shownotification" title=dom-showNotification>showNotification</a>(in DOMString title, in DOMString subtitle, in DOMString description);
  void <a href="#shownotification" title=dom-showNotification>showNotification</a>(in DOMString title, in DOMString subtitle, in DOMString description, in VoidCallback onclick);
};</pre>

  <p>Objects that implement the <code><a
   href="#workerglobalscope">WorkerGlobalScope</a></code> interface must also
   implement the <code><a href="#workerutils">WorkerUtils</a></code>
   interface.

  <p>Objects that implement the <code><a
   href="#workerutils">WorkerUtils</a></code> interface must also implement
   the <code>WindowTimers</code> interface. (This interface provides the
   <code title="">setTimeout()</code> method and its friends.)

  <p class=big-issue>Need to define a sync database API.</p>
  <!-- XXX ApplicationCache -->
  <!-- XXX a way to set cookies on the URL for the script -->
  <!-- XXX debugging: void log(in DOMString s); // log to console -->
  <!-- XXX debugging: onerror -->

  <hr>

  <p>The DOM APIs (<code>Node</code> objects, <code>Document</code> objects,
   etc) are not available to workers in this version of this specification.

  <h3 id=importing><span class=secno>3.1 </span>Importing scripts and
   libraries</h3>

  <p>When a script invokes the <dfn id=importscripts
   title=dom-WorkerGlobalScope-importScripts><code>importScripts(<var
   title="">urls</var>)</code></dfn> method on a <code><a
   href="#workerglobalscope">WorkerGlobalScope</a></code> object, the user
   agent must run the following steps:

  <ol>
   <li>
    <p>If there are no arguments, return without doing anything. Abort these
     steps.

   <li>
    <p><span title="resolve a url">Resolve</span> each argument.

   <li>
    <p>If any fail, throw a <code>SYNTAX_ERR</code> exception.
   </li>
   <!--
   <li><p>If any of the resulting <span title="absolute URL">absolute
   URLs</span> have an <span>origin</span> that is not the <span
   title="same origin">same</span> as the origin of the script that
   invoked the method, then throw a <span>security
   exception</span>.</p></li>
-->

   <li>
    <p>Attempt to <span>fetch</span> each resource identified by the
     resulting <span title="absolute URLs">absolute URL</span>.</p>

   <li>
    <p>For each argument in turn, in the order given, starting with the first
     one, run these substeps:</p>

    <ol>
     <li>
      <p>Wait for the fetching attempt for the corresponding resource to
       complete.</p>

      <p>If the fetching attempt failed, throw a <code>NETWORK_ERR</code>
       exception and abort all these steps.</p>

      <p>If the fetching attempt succeeded, then let <var
       title="">source</var> be the text of the resource that was obtained,
       and let <var title="">language</var> be JavaScript.</p>

      <p class=note>As with the worker's script, the script here is always
       assumed to be JavaScript, regardless of the MIME type.</p>
      <!-- XXX -->

     <li>
      <p><span>Create a script</span>, using <var title="">source</var> as
       the script source and <var title="">language</var> as the scripting
       language, using the same global object, browsing context, character
       encoding, base URL, and script group as the <span
       title=concept-script>script</span> that was created by the worker's <a
       href="#run-a">run a worker</a> algorithm.</p>

      <p>Let the newly created <span title=concept-script>script</span> run
       until it either returns, fails to parse, fails to catch an exception,
       or gets prematurely aborted by the "<a href="#kill-a">kill a
       worker</a>" or "<a href="#terminate">terminate a worker</a>"
       algorithms defined above.</p>

      <p>If it failed to parse, then throw a
       <code>SyntaxError</code><!-- XXX ref? --> exception and abort all
       these steps.</p>

      <p>If an exception was raised or if the script was prematurely aborted,
       then abort all these steps, letting the exception or aborting continue
       to be processed by the script that called the <code
       title=dom-WorkerGlobalScope-importScripts><a
       href="#importscripts">importScripts()</a></code> method.</p>

      <p>If the "<a href="#kill-a">kill a worker</a>" or "<a
       href="#terminate">terminate a worker</a>" algorithms abort the script
       then abort all these steps.</p>
    </ol>
  </ol>

  <h3 id=the-navigator><span class=secno>3.2 </span>The <code><a
   href="#navigator0">Navigator</a></code> object</h3>

  <p>The <dfn id=navigator title=dom-navigator><code>navigator</code></dfn>
   attribute of the <code><a href="#workerutils">WorkerUtils</a></code>
   interface must return an instance of the <code><a
   href="#navigator0">Navigator</a></code> interface, which represents the
   identity and state of the user agent (the client):

  <pre
   class=idl>[NoInterfaceObject] interface <dfn id=navigator0>Navigator</dfn> {
  // objects implementing this interface also implement the interfaces listed below
};</pre>

  <p>Objects implementing the <code><a
   href="#navigator0">Navigator</a></code> interface must also implement the
   <span>NavigatorID</span> and <span>NavigatorOnLine</span> interfaces
   specified in the HTML5 specification. <a href="#refsHTML5">[HTML5]</a>

  <p class=note>The <code><a href="#navigator0">Navigator</a></code>
   interface defined in this specification is different than the one defined
   in the HTML5 specification.

  <h3 id=apis-defined><span class=secno>3.3 </span>APIs defined in other
   specifications</h3>

  <p>The <dfn id=localstorage
   title=dom-localStorage><code>localStorage</code></dfn>, <dfn
   id=opendatabase title=dom-opendatabase><code>openDatabase()</code></dfn>
   must act as defined for the APIs with the same names on the
   <code>Window</code> object in the HTML5 specification, with the exception
   that where the API would use the <span>origin</span> of the <span>active
   document</span> of the <span>browsing context</span> of the
   <code>Window</code> object on which the method was supposedly invoked, it
   must instead use the <span>origin</span> of the script that invoked the
   method. <a href="#refsHTML5">[HTML5]</a>

  <p>The <dfn id=shownotification
   title=dom-showNotification><code>showNotification()</code></dfn> methods
   must act as defined for the APIs with the same names on the
   <code>Window</code> object in the HTML5 specification. <a
   href="#refsHTML5">[HTML5]</a>

  <h3 id=interface><span class=secno>3.4 </span>Interface objects and
   constructors</h3>

  <p>There must be no interface objects and constructors available in the
   global scope of scripts whose <span>script execution context</span> is a
   <code><a href="#workerglobalscope">WorkerGlobalScope</a></code> object
   except for the following:

  <ul>
   <li>
    <p><code>XMLHttpRequest</code> and all interface objects and constructors
     defined by the XMLHttpRequest specifications, except that the
     <span>document response entity body</span> must always be null. <a
     href="#refsXHR">[XHR]</a>

   <li>
    <p>The <code>WebSocket</code> interface object and constructor.

   <li>
    <p>The <code>MessageChannel</code> interface object and constructor.

   <li>
    <p>The <code title=dom-Worker><a href="#worker2">Worker()</a></code> and
     <code title=dom-SharedWorker><a href="#sharedworker0">SharedWorker(<var
     title="">url</var>)</a></code> constructors.
  </ul>

  <h3 id=worker0><span class=secno>3.5 </span>Worker locations</h3>

  <pre
   class=idl>[NoInterfaceObject] interface <dfn id=workerlocation>WorkerLocation</dfn> {
  readonly attribute DOMString <a href="#href" title=dom-WorkerLocation-href>href</a>;
  readonly attribute DOMString <a href="#protocol" title=dom-WorkerLocation-protocol>protocol</a>;
  readonly attribute DOMString <a href="#host" title=dom-WorkerLocation-host>host</a>;
  readonly attribute DOMString <a href="#hostname" title=dom-WorkerLocation-hostname>hostname</a>;
  readonly attribute DOMString <a href="#port0" title=dom-WorkerLocation-port>port</a>;
  readonly attribute DOMString <a href="#pathname" title=dom-WorkerLocation-pathname>pathname</a>;
  readonly attribute DOMString <a href="#search" title=dom-WorkerLocation-search>search</a>;
  readonly attribute DOMString <a href="#hash" title=dom-WorkerLocation-hash>hash</a>;
};</pre>

  <p>A <code><a href="#workerlocation">WorkerLocation</a></code> object
   represents an <span>absolute URL</span> set at its creation.

  <p>The <dfn id=href title=dom-WorkerLocation-href><code>href</code></dfn>
   attribute must return the <span>absolute URL</span> that the object
   represents.

  <p>The <code><a href="#workerlocation">WorkerLocation</a></code> interface
   also has the complement of <span>URL decomposition attributes</span>, <dfn
   id=protocol title=dom-WorkerLocation-protocol><code>protocol</code></dfn>,
   <dfn id=host title=dom-WorkerLocation-host><code>host</code></dfn>, <dfn
   id=port0 title=dom-WorkerLocation-port><code>port</code></dfn>, <dfn
   id=hostname title=dom-WorkerLocation-hostname><code>hostname</code></dfn>,
   <dfn id=pathname
   title=dom-WorkerLocation-pathname><code>pathname</code></dfn>, <dfn
   id=search title=dom-WorkerLocation-search><code>search</code></dfn>, and
   <dfn id=hash title=dom-WorkerLocation-hash><code>hash</code></dfn>. These
   must follow the rules given for URL decomposition attributes, with the
   <span title=concept-uda-input>input</span> being the <span>absolute
   URL</span> that the object represents (same as the <code
   title=dom-WorkerLocation-href><a href="#href">href</a></code> attribute),
   and the <span title=concept-uda-setter>common setter action</span> being a
   no-op, since the attributes are defined to be readonly. <a
   href="#refsHTML5">[HTML5]</a>

  <h2 class=no-num id=references>References</h2>

  <p class=big-issue>This section will be written in a future
   draft.<!--XXX-->

  <h2 class=no-num id=acknowledgements>Acknowledgements</h2>
  <!-- ACKS -->

  <p>Thanks to Aaron Boodman, Dmitry Titov, Jonas Sicking, Justin James,
   Kevin Hakanson, Maciej Stachowiak, Michael Nordman, Mike Smith, and Philip
   Taylor for their useful and substantial comments.

  <p>Huge thanks to the whole Gears team, who pioneered this technology and
   whose experience has been a huge influence on this specification.
